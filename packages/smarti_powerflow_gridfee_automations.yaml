# Power Management Package for Category 1

# Automation for Monitoring Power Consumption in Category 1 (Turn Off
automation:
  - alias: "Monitor Power Consumption for Category 1 (Turn Off)"
    mode: restart
    trigger:
      - platform: state
        entity_id: sensor.dynamic_power_sensor
    condition:
      - condition: template
        value_template: "{{ states('sensor.dynamic_power_sensor') | float(0) > (states('input_number.energy_target') | float(0) * 1000) }}"
      - condition: template
        value_template: "{{ states('sensor.total_controllable_power') | float(0) > 0 }}"
    action:
      - service: logbook.log
        data:
          name: "Power Management"
          message: "Starting Category 1 peak day check due to high power consumption"
      - service: script.check_category_1_peak_days

  - alias: "Monitor Power Consumption Decrease for Category 1 (Turn On)"
    mode: restart
    trigger:
      - platform: state
        entity_id: sensor.dynamic_power_sensor
    condition:
      - condition: template
        value_template: "{{ states('sensor.dynamic_power_sensor') | float(0) < (states('input_number.energy_target') | float(0) * 1000) }}"
    action:
      - service: logbook.log
        data:
          name: "Power Management"
          message: "Starting power gap calculation to turn on devices in Category 1 due to low power consumption"
      - service: script.calculate_power_gap_to_turn_on

# Scripts for Category 1 Power Management
script:
  check_category_1_peak_days:
    alias: Check Category 1 Peak Days
    sequence:
      - service: logbook.log
        data:
          name: "Power Management"
          message: "Checking peak days for Category 1"
      - choose:
          - conditions:
              - condition: state
                entity_id: input_number.peak_day_1
                state: "0"
            sequence:
              - service: script.check_category_1_monthly_peak
                data:
                  baseline: "{{ states('sensor.dynamic_power_sensor') }}"
          - conditions:
              - condition: state
                entity_id: input_number.peak_day_2
                state: "0"
            sequence:
              - service: script.check_category_1_monthly_peak
                data:
                  # Average of peak_day_1 and current measurement
                  baseline: "{{ ((states('input_number.peak_day_1') | float) * 1000 + states('sensor.dynamic_power_sensor') | float) / 2 }}"
          - conditions:
              - condition: state
                entity_id: input_number.peak_day_3
                state: "0"
            sequence:
              - service: script.check_category_1_monthly_peak
                data:
                  # Average of peak_day_1, peak_day_2, and current measurement
                  baseline: "{{ ((states('input_number.peak_day_1') | float) * 1000 + (states('input_number.peak_day_2') | float) * 1000 + states('sensor.dynamic_power_sensor') | float) / 3 }}"
        default:
          - service: script.check_category_1_monthly_peak
    mode: single

  check_category_1_monthly_peak:
    alias: Check Monthly Peak for Category 1
    sequence:
      - service: logbook.log
        data:
          name: "Power Management"
          message: "Checking monthly peak for Category 1"
      - condition: template
        # Multiply monthly peak energy by 1000 to convert from kW to W
        value_template: "{{ states('sensor.dynamic_power_sensor') | float(0) > (states('input_number.monthly_peak_energy') | float(0) * 1000) }}"
      - choose:
          - conditions:
              - condition: template
                value_template: "{{ states('sensor.dynamic_power_sensor') | float(0) > (states('input_number.monthly_peak_energy') | float(0) * 1000) }}"
            sequence:
              - service: script.calculate_power_gap_to_turn_off
          - conditions:
              - condition: template
                value_template: "{{ not (states('sensor.dynamic_power_sensor') | float(0) > (states('input_number.monthly_peak_energy') | float(0) * 1000)) }}"
            sequence:
              - service: script.notify_insufficient_power_category_1
    mode: single

  calculate_power_gap_to_turn_off:
    alias: Calculate Power Gap to Turn Off Devices in Category 1
    sequence:
      - delay: "00:00:01"
      - service: logbook.log
        data:
          name: "Power Management"
          message: "Starting power gap calculation. Initial power_gap: {{ states('sensor.dynamic_power_sensor') | float(0) - (states('input_number.energy_target') | float(0) * 1000) }} W"
      - variables:
          category_1_devices: "{{ state_attr('input_select.category_1_devices', 'options') | select('!=', 'No devices added') | list }}"
          power_gap: "{{ states('sensor.dynamic_power_sensor') | float(0) - (states('input_number.energy_target') | float(0) * 1000) }}"
      - repeat:
          count: 20 # Maximum devices to iterate
          sequence:
            - variables:
                entity_id: "{{ category_1_devices[repeat.index - 1] if repeat.index - 1 < category_1_devices | length else None }}"
                input_boolean_id: "input_boolean.device_turned_off_{{ repeat.index }}"
                input_text_id: "input_text.hvac_mode_{{ repeat.index }}" # Corresponding input_text for HVAC mode
                power_sensor: "{{ 'sensor.' ~ entity_id.split('.')[1] ~ '_power' if entity_id else None }}"
                device_power: "{{ states(power_sensor) | float(0) if power_sensor else 0 }}"
                hvac_mode: >
                  {% set mode = state_attr(entity_id, 'hvac_mode') %}
                  {% if mode in ['off', 'dry', 'heat', 'auto', 'heat/cool', 'fan only', 'cool'] %}
                    {{ mode }}
                  {% else %}
                    'off'
                  {% endif %}

            # Check conditions to proceed with turning off the device
            - condition: template
              value_template: "{{ entity_id is not none and power_gap > 0 and device_power > 0 }}"

            # Determine action based on entity type and turn off the device
            - choose:
                - conditions:
                    - condition: template
                      value_template: "{{ entity_id.startswith('climate.') }}"
                  sequence:
                    # Save the current HVAC mode to input_text before turning off
                    - service: input_text.set_value
                      target:
                        entity_id: "{{ input_text_id }}"
                      data:
                        value: "{{ hvac_mode | string }}" # Ensuring mode is stored as a simple string
                    # Turn off the HVAC entity
                    - service: climate.set_hvac_mode
                      target:
                        entity_id: "{{ entity_id }}"
                      data:
                        hvac_mode: "off"
                    - service: logbook.log
                      data:
                        name: "Power Management"
                        message: "Turning off {{ entity_id }} (climate entity) to reduce power by {{ device_power }} W. Current power gap before turn-off: {{ power_gap }} W"

                - conditions:
                    - condition: template
                      value_template: "{{ entity_id.startswith('switch.') }}"
                  sequence:
                    - service: homeassistant.turn_off
                      target:
                        entity_id: "{{ entity_id }}"
                    - service: logbook.log
                      data:
                        name: "Power Management"
                        message: "Turning off {{ entity_id }} (switch entity) to reduce power by {{ device_power }} W. Current power gap before turn-off: {{ power_gap }} W"

            # Set the input boolean to 'on' to track the turned-off status
            - service: input_boolean.turn_on
              target:
                entity_id: "{{ input_boolean_id }}"

            # Log action and update power gap after device turn-off
            - service: logbook.log
              data:
                name: "Power Management"
                message: "Device {{ entity_id }} turned off. Updated power gap after turn-off: {{ power_gap }} W"

            # Recalculate power gap after each turn-off action
            - variables:
                power_gap: "{{ states('sensor.dynamic_power_sensor') | float(0) - (states('input_number.energy_target') | float(0) * 1000) }}"
            - delay: "00:00:15"

  calculate_power_gap_to_turn_on:
    alias: Turn On Devices After Power Gap Is Resolved
    sequence:
      - variables:
          category_1_devices: "{{ state_attr('input_select.category_1_devices', 'options') | select('!=', 'No devices added') | list }}"
      - repeat:
          count: 20 # Maximum devices to iterate
          sequence:
            - variables:
                entity_id: "{{ category_1_devices[repeat.index - 1] if repeat.index - 1 < category_1_devices | length else None }}"
                input_boolean_id: "input_boolean.device_turned_off_{{ repeat.index }}"

            # Only proceed if the device's input boolean is 'on', indicating it was turned off by the automation
            - condition: template
              value_template: "{{ is_state(input_boolean_id, 'on') }}"

            # Choose action to turn device back on based on its type
            - choose:
                - conditions:
                    - condition: template
                      value_template: "{{ entity_id.startswith('climate.') }}"
                  sequence:
                    - service: climate.set_hvac_mode
                      target:
                        entity_id: "{{ entity_id }}"
                      data:
                        hvac_mode: "auto"
                    - service: logbook.log
                      data:
                        name: "Power Management"
                        message: "Turning on {{ entity_id }} (climate entity) as power usage is within target."

                - conditions:
                    - condition: template
                      value_template: "{{ entity_id.startswith('switch.') }}"
                  sequence:
                    - service: homeassistant.turn_on
                      target:
                        entity_id: "{{ entity_id }}"
                    - service: logbook.log
                      data:
                        name: "Power Management"
                        message: "Turning on {{ entity_id }} (switch entity) as power usage is within target."

            # Reset the input boolean to 'off' after turning the device back on
            - service: input_boolean.turn_off
              target:
                entity_id: "{{ input_boolean_id }}"
